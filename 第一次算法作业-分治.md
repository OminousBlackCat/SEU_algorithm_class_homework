# 第一次作业

## 姓名：OminousBlackCat                                学号：514

## 题目一：  <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" title="二维数组中的查找">二维数组中的查找</a>
**题目描述**：在一个 $n * m$的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**示例：** 现有矩阵 $matrix$​​ 如下:

$\left[
\matrix{
  1&4&7&11&15\\
  2&5&8&12&19\\
  3&6&9&16&22\\
  10&13&14&17&24\\
  18&21&23&26&30\\
}
\right]$​​​​​

给定 $target=5$​，返回 $true$​。

给定 $target = 20$​，返回 $false$​。

**限制：**  

- $0 <= n <= 1000$
- $0 <= m <= 1000$



**题解：**

算法思路：

+ **思路一**：在二维数组中查找，第一反应是直接套用一维数组的二分查找，由于该数组的每行与每列都是有序数组，可以直接对每行进行二分搜索，可以在m次log(n)（n>m）的时间复杂度内完成搜索。但是此算法的问题在于仅仅用到了行（列）的有序信息，并没有使用到全局有序信息，因此此算法肯定还可以再优化；
+ **思路二**：由于一维的二分是将数组分为前一半和后一半。对于二维数组，将维数上升之后，或许可以将数组分为四等分，因此可以观察二维数组中间数字与待查找数字之间的关系。如示例，待查找值假设为**19** ，对于二维数组最中间的值**9**，19>9，至少可以判定数字9的**上方**与**左侧**都不可能有19出现。因此可以**排除中间数字的左上部分**。同理，若待查找值小于9，则可以确定待查找值只可能处于9的左上部分。即每次查找可以剔除1/4或者3/4，对于剩下的3/4（1/4），可以对每一块进行相同的操作，直到最后每块仅剩4个数字；此算法的时间复杂度应为O(log(mn))，但此算法最大的问题在于，由于此二维数组并不一定是正四边形，对于每一小块，不容易寻找最中间的数字，并且需要多次对二维数组进行拆分与递归调用函数，代码比较难以实现；
+ **思路三**：由于是有序二维数组，在数组中，在行的层面上，从左到右是递增的，在列的层面上，从上到下是递增的。因此当向左递进查找时，数字是逐渐减小的，向下递进查找时，数字是逐渐增大的。可以利用此性质，如果能保证从数组的某一地方开始查找，顺着递增或递减状态向某个方向查找，并且确保不会遗漏，就可以寻找到一条可行路径至待查找数字。因此可以从二维数组的右上角开始查找，如本例，从**15**开始查找，待查找值为**10**，首先15>10，因此应该向左进行查找，到11；11>10，继续向左，到7；7<10，应向下至8……随后便可以产生序列：**15->11->7->8->9->14->13->10**。显然，最坏时间复杂度为O(m+n)。此种算法利用了二维数组的全部信息，并且，本质上是与有序二叉树查找思路一致，因为对于右上角数字（**15**），其左侧（**11**可以看做左子树）数字小于它，下侧（**19**可以看做右子树大于它），对于**11**,其左侧与下侧也满足同样的规律。但由于此二叉树并不平衡，并无法在最佳时间复杂度内完成。

**伪代码：**

伪代码这里对思路二与思路三进行描述：

* 思路二：

  ```
  Algorithm B: Find target number in martrix
  Input: Martrix A(2-dim array)(with m*columns, n*row), target number b
  Output:ture(if A has b) or false(if A does't have b)
  B(A,b):
  Find the middle number _mid in A;
  if(A.m <=2 && A.n <=2):
  	return A[0][0] == b | A[0][1] == b | A[1][0] == b | A[1][1] == b;
  if(_mid > b):
  	let _q_A = left and top quarter of A;
  	return B(_q_A, b);
  else(_mid < b):
  	let _q_A_1 = left and bottom quarter of A;
      let _q_A_2 = right and top quarter of A;
      let _q_A_3 = right and bottom quarter of A;
      return B(_q_A_1, b) | B(_q_A_2, b) | B(_q_A_3, b);
  ```

* 思路三：

  ```
  Algorithm C: Find target number in martrix
  Input: Martrix A(2-dim array)(with m*columns, n*row), target number b
  Output:ture(if A has b) or false(if A does't have b)
  C(A,b):
  let _compare = A[0][m] //Upper right corner element of A
  let _index = (0, m)
  while(ture) do:
  	if(b > _compare):
  		if _index out of range: return false;
  		else: _index move one step to down;
  	if(b == _compare):
  		return ture;
  	if(b < _compare):
  		if _index out of range: return false;
  		else: _index move one step to left;
  	_compare = A(_index);	
  ```

  

**代码：**

这里仅真正实现了思路三：

```c++
bool findTargetInArray(vector<vector<int>> nums, int target){
    int row_index = 0;
    int column_index = nums[0].length() - 1;
    int compare = nums[row_index][column_index];
    while(ture){
        if(target > compare){
            if(row_index + 1 >= num.length()){
                return false;
            }else{
             	row_index = row_index + 1;   
            }
        }
        if(target == compare){
            return ture;
        }
        if(target < compare){
            if(column_index - 1 < 0){
                return false;
            }else{
                comlumn_index = column_index - 1;
            }
        }
        compare = nums[row_index][column_index];
    }
    return false;
}
```





## 题目二： <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" title="前 K 个高频元素">前 K 个高频元素</a>

**题目描述：** 给你一个整数数组$nums$和一个整数$k$，请你返回其中出现频率前$k$高的元素。你可以按**任意顺序**返回答案。

**示例 1：**
输入：$nums = [1, 1, 1, 2, 2, 3], k = 2$​​
输出：$[1, 2]$​

**示例 2：**
输入：$nums = [1], k = 1$​​
输出：$[1]$​

**提示：**

- $1 <= nums.length <= 10^5$
- $k$ 的取值范围是$[1, \rm{数组中不相同的元素的个数}]$
- 题目数据保证答案唯一，换句话说，数组中前$k$个高频元素的集合是唯一的



**题解：**

算法思路：描述一下算法的思想

伪代码：

```

```

代码：

```

```





## 题目三： <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" title="数组中的逆序对">数组中的逆序对</a>

**题目描述：** 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**示例 ：**
输入：$[7,5,6,4]$​
输出：$5$​

**限制：**

- $0 <= \rm数组长度 <= 50000$



**题解：**

算法思路：描述一下算法的思想

伪代码：

```

```

代码：

```c++
#include <iostream>
#include <vector>

using namespace std;

int reverseVector(vector<int>& nums, int start, int end) {
    if (start == end) {
    	// 递归出口： 头尾相等
        return 0;
    }
    else if (start + 1 == end) {
        // 递归出口：仅有两个元素
        if (nums[start] > nums[end]) {
            return 1;
        }
        else {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
        }
        return 0;
    }
    else {
        int additional = reverseVector(nums, start, (start + end) / 2) + reverseVector(nums, (start + end) / 2 + 1, end);
        vector<int> append;
        //需要对内部元素进行排序并且求出额外的逆序对
        int i = start;
        int j = (start + end) / 2 + 1;
        while (i <= (start + end) / 2 && j <= end) {
            if (nums[i] > nums[j]) {
                additional = additional + (end - j + 1);
                append.push_back(nums[i]);
                i++;
            }
            else {
                append.push_back(nums[j]);
                j++;
            }
        }
        if (i <= (start + end) / 2) {
            while (i <= (start + end) / 2) {
                append.push_back(nums[i]);
                i++;
            }
        }
        if (j <= end) {
            while (j <= end) {
                append.push_back(nums[j]);
                j++;
            }
        }
        for (int n = 0; n < append.size(); n++) {
            nums[n + start] = append[n];
        }
        return(additional);
    }
    return 0;
}
```

