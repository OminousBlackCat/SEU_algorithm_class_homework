# 第二次作业

## 姓名：xxx                                学号：xxxxxx

## 题目一：[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

**题目描述**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例：** 

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

**题解：**

**算法思路：**

简单描述算法的求解思路

**伪代码：**

```

```

**代码：**

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid){
    vector<vector<int>> answer = obstacleGrid;
    if (obstacleGrid[0][0] != 1) {
        answer[0][0] = 1;
    }
    else {
        return 0;
    }
    bool is_x_have_obs = false;
    for (int x = 1; x < obstacleGrid[0].size(); x++) {
        if (!is_x_have_obs) {
            if (obstacleGrid[0][x] != 1) {
                answer[0][x] = 1;
            }
            else {
                answer[0][x] = 0;
                is_x_have_obs = true;
            }
        }
        else {
            answer[0][x] = 0;
        }
    }
    bool is_y_have_obs = false;
    for (int y = 1; y < obstacleGrid.size(); y++) {
        if (!is_y_have_obs) {
            if (obstacleGrid[y][0] != 1) {
                answer[y][0] = 1;
            }
            else {
                answer[y][0] = 0;
                is_y_have_obs = true;
            }
        }
        else {
            answer[y][0] = 0;
        }
    }
    for (int x = 1; x < obstacleGrid[0].size(); x++) {
        for (int y = 1; y < obstacleGrid.size(); y++) {
            if (obstacleGrid[y][x] != 1) {
                answer[y][x] = answer[y-1][x] + answer[y][x - 1];
            }
            else {
                answer[y][x] = 0;
            }
        }
    }
    return answer[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];
}
```

## 题目二： [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

**题目描述：** 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈** ，这意味着**第一个房屋和最后一个房屋是紧挨着的**。同时，**相邻的房屋装有相互连通的防盗系统**，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你在**不触动警报装置**的情况下 ，今晚能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。
```

**提示：**

**题解：**

**算法思路：**

简单描述算法的求解思路

**伪代码：**

```

```

**代码：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int rob_temp(vector<int>& nums) {
    vector<int> answer = nums;
    if (nums.size() <= 1) {
        return answer[0];
    }
    else {
        if (nums[1] < nums[0]) {
            answer[1] = nums[0];
        }
    }
    if (nums.size() > 2) {
        for (int i = 2; i < nums.size(); i++) {
            if (nums[i] + answer[i - 2] >= answer[i - 1]) {
                answer[i] = nums[i] + answer[i - 2];
            }
            else {
                answer[i] = answer[i - 1];
            }
        }
    }
    return answer[nums.size() - 1];
}
int rob(vector<int>& nums) {
    vector<int>::const_iterator start = nums.begin();
    vector<int>::const_iterator beforeEnd = nums.end() - 1;
    vector<int>::const_iterator next = nums.begin() + 1;
    vector<int>::const_iterator ending = nums.end();

    if (nums.size() == 1) {
        return nums[0];
    }
    else {
        vector<int> temp_A(start, beforeEnd);
        vector<int> temp_B(next, ending);
        return rob_temp(temp_A) >= rob_temp(temp_B) ? rob_temp(temp_A) : rob_temp(temp_B);
    }
    return nums[0];
}
```

## 题目三： <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" title="数组中的逆序对">[不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)</a>

**题目描述：** 

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

**示例 ：**

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下有 3 种可以从 s 中得到 "rabbit" 的方案。
```

**rabb** b **it**

**ra** b **bbit**

**rab** b **bit**



**题解：**

**算法思路：**

简单描述算法的求解思路

**伪代码：**

```

```

**代码：**

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;
static unsigned int table[1024][1024];

int numDistinct(string s, string t) {
    for (int i = 0; i < t.size(); i++) {
        for (int j = 0; j < s.size(); j++) {
            table[i][j] = 0;
        }
    }
    // 初始化表格第一行与第一列
    // 初始化第一行
    for (int j = 0; j < s.size(); j++) {
        if (s[j] == t[0]) {
            if (j != 0) {
                table[0][j] = table[0][j - 1] + 1;
            }
            else
            {
                table[0][j] = 1;
            }

        }
        else {
            if (j != 0) {
                table[0][j] = table[0][j - 1];
            }
            else {
                table[0][j] = 0;
            }

        }
    }
    // 初始化第一列
    // 第一列除了第一个元素可能是1，其他一定是0 不需要初始化
    for (int i = 1; i < t.size(); i++) {
        for (int j = 1; j < s.size(); j++) {
            if (s[j] == t[i]) {
                table[i][j] = table[i - 1][j - 1] + table[i][j - 1];
            }
            else {
                table[i][j] = table[i][j - 1];
            }
        }
    }
    return table[t.size() - 1][s.size() - 1];
}
```

